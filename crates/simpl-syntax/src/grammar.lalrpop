use std::str::FromStr;
use crate::ast::{Symbol, Expr, Lit};

grammar;

// Literal expressions

pub LitExpr: Lit = {
    Bool => Lit::Bool(<>),
    Int => Lit::Int(<>),
    Float => Lit::Float(<>),
}

pub Bool: bool = {
    "true" => true,
    "false" => false,
}

pub Int: i64 = {
    <s:r"[0-9]+"> => i64::from_str(s).unwrap(),
}

pub Float: f64 = {
    <s:r"[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap(),
}

// Variable references

pub Ident: Symbol = {
    <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => <>.into(),
}

pub VarExpr: Expr = {
    Ident => Expr::Var {name: <>},
}

// If expressions

pub IfExpr: Expr = {
    "if" <test:Expr> "then" <then_branch:Expr> "else" <else_branch:Expr> ";"
         => Expr::If{ test: box test,
                    then_branch: box then_branch,
                    else_branch: box else_branch
                   },
}

// Let bindings

pub LetExpr: Expr = {
    "let" <bindings:Comma1<Binding>> "in" <body:Expr> ";"
        => Expr::Let {bindings, body: box body},
}

pub Binding: (Symbol, Expr) = {
    <var:Ident> "=" <val:Expr> => (var, val),
}

// Lambda abstraction

pub LambdaExpr: Expr = {
   "\\" "(" <args:Comma<Ident>> ")" "->" <body:Expr> ";"
        => Expr::Lambda {args, body: box body},
}

// Function application

pub AppExpr: Expr = {
    <func:Expr> "(" <args:Comma<Expr>> ")" => Expr::App {func: box func, args},
}

// Expressions

pub Expr: Expr = {
    LitExpr    => Expr::Lit {val: <>},
    VarExpr    => <>,
    IfExpr     => <>,
    LetExpr    => <>,
    LambdaExpr => <>,
    AppExpr    => <>,
}

#[inline]
Delim<T, D>: Vec<T> = {
    <v:(<T> <D>)*> <e:T?> => match e {
        None => v.iter().map(|x| x.0.clone()).collect(),
        Some(e) => {
            let mut v = v.iter().map(|x| x.0.clone()).collect::<Vec<_>>();
            v.push(e);
            v
        }
    }
}

#[inline]
Delim1<T, D>: Vec<T> = {
    <v:(<T> <D>)*> <e:T> => {
        let mut v = v.iter().map(|x| x.0.clone()).collect::<Vec<_>>();
        v.push(e);
        v
    }
}

#[inline]
Comma<T> = Delim<T, ",">;

#[inline]
Comma1<T> = Delim1<T, ",">;
